<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | Jesse Cravens]]></title>
  <link href="http://jessecravens.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://jessecravens.com/"/>
  <updated>2013-06-18T00:11:17-05:00</updated>
  <id>http://jessecravens.com/</id>
  <author>
    <name><![CDATA[Jesse Cravens]]></name>
    <email><![CDATA[jesse.cravens@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Push Notifications to the Browser with Server Sent Events]]></title>
    <link href="http://jessecravens.com/blog/2013/04/21/push-notifications-to-the-browser-with-server-sent-events/"/>
    <updated>2013-04-21T15:44:00-05:00</updated>
    <id>http://jessecravens.com/blog/2013/04/21/push-notifications-to-the-browser-with-server-sent-events</id>
    <content type="html"><![CDATA[<p>Mirrored from: <a href="http://html5hacks.com/blog/2013/04/21/push-notifications-to-the-browser-with-server-sent-events/">http://html5hacks.com/blog/2013/04/21/push-notifications-to-the-browser-with-server-sent-events/</a></p>

<p>Created by Opera, Server Sent Events standardizes Comet technologies. The standard intends to enable native real time updates through a simple JavaScript API called EventSource, which connects to servers that asynchronously push data updates to clients via HTTP Streaming. Server Sent Events use a single, unidirectional, persistent connection between the browser and the server.</p>

<p>Unlike the Web Socket API, Server Sent Events and EventSource object use HTTP to enable real-time server push capabilities within your application. HTTP Streaming predates the WebSocket API, and it is often referred to as Comet or server push. The exciting part here is that the Server Sent Events API intends to standardize the Comet technique, making it trivial to implement in the browser.</p>

<h2>What is HTTP Streaming?</h2>

<p>In a standard HTTP request and response between a web browser and a web server, the server will close the connection once it has completed the processing of the request. HTTP streaming, or Comet, differs in that the server maintains a persistent, open connection with the browser.</p>

<p>It is important to note that not all web servers are capable of streaming. Only evented servers such as Node.js, Tornado, or Thin are equipped incorporate an event loop that is optimal for supporting HTTP streaming. These, non-blocking servers handle persistent connections from a large number of concurrent requests very well.</p>

<p>A complete discussion on evented vs. threaded servers is out of scope for this post, but that being said, in the upcoming hack we will provide a very simple evented server implementation example to get you started. We provide a simple browser based JavaScript to connect to the server, and a server side implementation using Ruby, Thin, and Sinatra.
For the record, this is also very easy to do with Node.js.</p>

<p>Here is a link to the companion github repository:
<a href="https://github.com/html5hacks/chapter9">https://github.com/html5hacks/chapter9</a></p>

<h2>Ruby’s Sinatra</h2>

<p>The Sinatra documentation describes itself as a “DSL for quickly creating web applications in Ruby with minimal effort.”
This text has focused primarily on Node.js (HTTP Server) and Express.js (web application framework) to quickly generate server side implementations for hacking out functionality.</p>

<p>It would a disservice to not mention Ruby, Rails and Sinatra in the same or similar light as we have Node.js in this text. Although learning Ruby is another learning curve, in the larger scheme of programming languages it is a less daunting curve than most. And as most die-hard Rubyists will preach, it is arguably the most elegant and fun to write of all modern programming languages. Ruby on Rails, and its little brother Sinatra are also great web application frameworks to start with if you are new to web application development.</p>

<p>Much like Node.js and Express, Sinatra makes building small server implementations nearly trivial. So for the context of HTML5 Hacks, that allows us to focus our efforts on programming in the browser.</p>

<p>For now let’s build a simple HTTP Streaming server using Sinatra.</p>

<p>To get started with Ruby On Rails or Sinatra, check out the great documentation available at <a href="http://guides.rubyonrails.org/getting_started.html">http://guides.rubyonrails.org/getting_started.html</a> and <a href="http://sinatrarb.com/intro">http://sinatrarb.com/intro</a>, respectively.</p>

<h2>Building Push Notifications</h2>

<p>Our goal in the next hack is to build a simple streaming server and use the EventSource object to open a persistent connection from the browser. We will then push notifcations from one ‘admin’ browser to all the connected receivers. Sounds simple, right? Let’s get started.</p>

<h2>A Simple HTTP Streaming Server</h2>

<p>Open up a file and name it stream.rb. Then add the following:
Simple requiring of Sinatra and the JSON library:</p>

<p>{% codeblock stream.rb %}</p>

<p>  require 'json'
  require 'sinatra'</p>

<p>{% endcodeblock %}</p>

<p>Then, we set up a public folder, and set the server to use the evented ruby server, Thin.</p>

<p>{% codeblock stream.rb %}</p>

<p>  set :public_folder, Proc.new { File.join(root, "public") }
  set server: 'thin'</p>

<p>{% endcodeblock %}</p>

<p>Set up two routs for serving our 2 pages: index and admin. We will use Erb as our templating language. The details are out of scope, but our use is very minimal. More on Erb here: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/erb/rdoc/ERB.html">http://ruby-doc.org/stdlib-1.9.3/libdoc/erb/rdoc/ERB.html</a></p>

<p>{% codeblock stream.rb %}</p>

<p>  get '/' do</p>

<pre><code>erb :index
</code></pre>

<p>  end</p>

<p>  get '/admin' do</p>

<pre><code>erb :admin
</code></pre>

<p>  end</p>

<p>{% endcodeblock %}</p>

<p>We’d like to timestamp each notification, so here is a very simple function definition.</p>

<p>{% codeblock stream.rb %}</p>

<p>  def timestamp</p>

<pre><code>Time.now.strftime("%H:%M:%S")
</code></pre>

<p>  end</p>

<p>{% endcodeblock %}</p>

<p>We also set up two empty arrays: one to hold the connections and the other to hold out notifications.</p>

<p>{% codeblock stream.rb %}</p>

<p>  connections = []
  notifications = []</p>

<p>{% endcodeblock %}</p>

<p>Now, for the routes. When our browser loads it s page, we have JavaScript running which will use the EventSource object to connect to a url here: http://localhost:4567/connect.</p>

<p>More on EventSource later.</p>

<p>But for now you can see the magic of the evented HTTP stream, the connection is held open until a callback is fired to close the stream.</p>

<p>{% codeblock stream.rb %}</p>

<p>  get '/connect', provides: 'text/event-stream' do</p>

<pre><code>stream :keep_open do |out|
  connections &lt;&lt; out

  #out.callback on stream close evt. 
  out.callback { 
    #delete the connection 
    connections.delete(out) 
  } 
end
</code></pre>

<p>  end</p>

<p>{% endcodeblock %}</p>

<p>Finally, any data this posted to the /push route is pushed out to each connected device.</p>

<p>{% codeblock stream.rb %}</p>

<p>  post '/push' do</p>

<pre><code>puts params
#Add the timestamp to the notification
notification = params.merge( {'timestamp' =&gt; timestamp}).to_json

notifications &lt;&lt; notification

notifications.shift if notifications.length &gt; 10
connections.each { |out| out &lt;&lt; "data: #{notification}\n\n"}
</code></pre>

<p>  end</p>

<p>{% endcodeblock %}</p>

<p>As we said before, you can just follow the instructions at our git repository to pull down and build this code. Or if you have been following along, launch a terminal, navigate to the directory where you code is, and run:</p>

<p>{% codeblock cli %}</p>

<p>  $ ruby stream.rb</p>

<p>{% endcodeblock %}</p>

<p>Figure 9.15 Starting the Sinatra Server</p>

<p><img class="figure" alt="Figure 7-2" src="http://jessecravens.com/images/chapter9-images/9-15.png"></p>

<p>Alright, so now that we have out Sinatra app up and running with custom routes to handle incoming requests from our browser.</p>

<p>If this doesn’t make complete sense yet, just hang loose. In the upcoming subsections, the rest of the items will start to fall into place.</p>

<h2>Set Up the HTML pages</h2>

<p>We will be building 2 pages: one for the admin to push out notifications, and the other will be for the connected receivers to receive the notification. Both of these ‘views’ will share the same layout, as such:</p>

<p>{% codeblock index.html %}</p>

<p><html>
  <head></p>

<pre><code>&lt;title&gt;HTML5 Hacks - Server Sent Events&lt;/title&gt; 
&lt;meta charset="utf-8" /&gt;

&lt;script src=”http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js”&gt;
</code></pre>

<p></script></p>

<pre><code>&lt;script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1/jquery-ui.js"&gt; &lt;/script&gt;
&lt;script src="jquery.notify.js" type="text/javascript"&gt;&lt;/script&gt; 
&lt;link rel="stylesheet" type="text/css" href="style.css"&gt;
&lt;link rel="stylesheet" type="text/css" href="ui.notify.css"&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;!—- implementation specific here --&gt;
</code></pre>

<p>  </body>
</html></p>

<p>{% endcodeblock %}</p>

<p>The admin page will contain an input tag and a simple button.</p>

<p>{% codeblock admin.html %}</p>

<div id="wrapper">
    <input type="text" id="message" placeholder="Enter Notification Here" /><br>
    <input type=”button” id="send" data-role="button">push</input>
</div>


<p>{% endcodeblock %}</p>

<p>And our receiver pages will display a simple piece of text:</p>

<p>{% codeblock receiver.html %}</p>

<div id="wrapper">
  <p>Don't Mind me ... Just Waiting for a Push Notification from HTML5 Hacks.</p>
</div>


<p>{% endcodeblock %}</p>

<p>By launching one browser window to http://localhost:4567/admin you should now see our admin form.</p>

<p>Figure 9.16 The initial admin page</p>

<p><img class="figure" alt="Figure 9-16" src="http://jessecravens.com/images/chapter9-images/9-16.png"></p>

<p>And, navigate to http://localhost:4567 in your browser and you should see.</p>

<p>Figure 9.17 The initial index page</p>

<p><img class="figure" alt="Figure 9-17" src="http://jessecravens.com/images/chapter9-images/9-17.png"></p>

<h2>Adding a bit of jQuery</h2>

<p>We need to add a bit of JavaScript to attach an event listener to the “send” button. This snippet will prevent the default submission of the form and post the notifcation object to the server as JSON.
Notice the url /push maps to the route we defined in our Sinatra app.</p>

<p>{% codeblock push.js %}</p>

<p> $('#send').click(function(event) {</p>

<pre><code>event.preventDefault();
</code></pre>

<p>   var notifcation = { notifcation: $('#notification').val()};</p>

<pre><code>$.post( '/push', notifcation,'json');
</code></pre>

<p> })</p>

<p>{% endcodeblock %}</p>

<p>Now, lets open up five browser windows: one admin at http://localhost:4567/admin and four more receivers at http://localhost:4567</p>

<p>Figure 9.18 Opening 5 browser windows</p>

<p><img class="figure" alt="Figure 9-18" src="http://jessecravens.com/images/chapter9-images/9-18.png"></p>

<p>Looking good.</p>

<p>But before we get started, lets set up our EventSource.</p>

<h2>EventSource</h2>

<p>Event Source is a super simple JavaScript API for opening a connection with an HTTP stream.
Because our receiver pages are just ‘dumb’ terminals that receive data, we have an ideal scenario for Server Side Events.
Earlier, when we discussed the Sinatra app, we showed exposing a route for the browser to connect to an HTTP stream. Well, this is where we connect!</p>

<p>{% codeblock es.js %}</p>

<p>  var es = new EventSource('/connect');</p>

<p>  es.onmessage = function(e) {</p>

<pre><code>var msg = $.parseJSON(event.data);

    // … do something
</code></pre>

<p>  }</p>

<p>{% endcodeblock %}</p>

<p>Now we can add a simple notification with the available data,</p>

<p>{% codeblock es.js %}</p>

<p>  var es = new EventSource('/connect');</p>

<p>  es.onmessage = function(e) {</p>

<pre><code>var msg = $.parseJSON(event.data);
</code></pre>

<p>// … Notify
  }</p>

<p>{% endcodeblock %}</p>

<p>And here is the final script for the admin:</p>

<p>{% codeblock es.js %}</p>

<p>  $(function() {</p>

<pre><code>$('#send').click(function(event) {
  event.preventDefault();

  var notification = {message: $('#notification').val()};

  $.post( '/push', notification,'json');
}) 
</code></pre>

<p>  });</p>

<p>{% endcodeblock %}</p>

<h2>Installing jQuery.notify</h2>

<p>For our Push Notifcations we will make use of Eric Hynds great jQuery plugin jquery-notify, located here at github: [github.com/ehynds/jquery-notify] (https://github.com/ehynds/jquery-notify)</p>

<p>In order to display the notification, we will need to include some markup to the receiver page.</p>

<p>{% codeblock receiver.html %}</p>

<div id="container" style="display:none">
    <div id="basic-template">
        <a class="ui-notify-cross ui-notify-close" href="#">x</a>
        <h1>#{title}</h1>
        <p>#{text}</p>
    </div>
</div>


<p>{% endcodeblock %}</p>

<p>This creates a hidden div tag in the bottom of the document. We are not showing the CSS that uses “display: none” to hide it, but you can see more by examining the source code in the companion git repo.</p>

<p>Figure 9.19 Inspecting the DOM in Chrome Dev Tools</p>

<p><img class="figure" alt="Figure 9-19" src="http://jessecravens.com/images/chapter9-images/9-19.png"></p>

<p>In order for jQuery.notify to initialize, you must first call the following:</p>

<p>{% codeblock es.js %}</p>

<p>$("#container").notify({
  speed: 500,
  expires: false
});</p>

<p>{% endcodeblock %}</p>

<p>And here is the final script for the receiver:</p>

<p>{% codeblock es.js %}</p>

<p>$(function() {</p>

<p>  $("#container").notify({</p>

<pre><code>  speed: 500,
  expires: false
</code></pre>

<p>  });</p>

<p>  var es = new EventSource('/connect');
  es.onmessage = function(e) {</p>

<pre><code>var msg = $.parseJSON(event.data);
$("#container").notify("create", {
    title: msg.timestamp,
    text: msg.notification
});
</code></pre>

<p>  }<br/>
})</p>

<p>{% endcodeblock %}</p>

<p>It’s that simple. The EventSource API is minimal and plugging it into a web framework like Sinatra or Node.js is straightforward.</p>

<p>Now, as we submit notifications from the admin page, our receiver pages are updated with time stamped notifications:</p>

<p>Figure 9.20 Pushing Notifications to the Connected Browsers</p>

<p><img class="figure" alt="Figure 9-20" src="http://jessecravens.com/images/chapter9-images/9-20.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML5.tx 2013]]></title>
    <link href="http://jessecravens.com/blog/2013/02/03/html5-dot-tx-2013/"/>
    <updated>2013-02-03T23:09:00-06:00</updated>
    <id>http://jessecravens.com/blog/2013/02/03/html5-dot-tx-2013</id>
    <content type="html"><![CDATA[<h3>Embedded JavaScript, HTML5 and the Internet of Things</h3>

<iframe width="560" height="315" src="http://www.youtube.com/embed/H00_BGRkBRM" frameborder="0" allowfullscreen></iframe>




<script async class="speakerdeck-embed" data-slide="46" data-id="92b31ab050b501308fcd1231381d555c" data-ratio="1.2994923857868" src="http://jessecravens.com//speakerdeck.com/assets/embed.js"></script>


<p>I had a great time presenting at HTML5.tx 2013; here is an embed above of the slide deck. I should have the trailr node module in a presentable format soon and I'll tweet its inclusion in NPM. I have a placeholder here: <a href="https://npmjs.org/package/trailr">trailr at npm</a></p>

<p>I also pushed out the ver.1 trailr-admin UI here: <a href="http://trailr-admin.herokuapp.com/dashboard">trailr-admin.herokuapp.com</a></p>

<p>Most of the demos are included in the nodejshacks-emedded repo here: <a href="https://github.com/nodejshacks/nodejshacks-embedded">https://github.com/nodejshacks</a></p>

<p>Very soon, initial documentation will be available at: <a href="http://trailr.io">trailr.io</a></p>

<p><img class="" alt=""  src="http://jessecravens.com/images/html5tx2013/embedded.JPG"></p>

<p>Photo credit: Mitch Fincher: <a href="http://mitchfincher.blogspot.com/2013/02/pictures-from-html5tx-2013-in-austin-tx.html">mitchfincher.blogspot.com</a></p>

<h3>HTML5 Canvas View</h3>

<p><img class="" alt=""  src="http://jessecravens.com/images/html5tx2013/dash.png"></p>

<h3>Node.js trailr module - Web Based Edit (Ace Editor) and WebSocket Deploy to Arduino</h3>

<p><img class="" alt=""  src="http://jessecravens.com/images/html5tx2013/edit.png"></p>

<p><img class="" alt=""  src="http://jessecravens.com/images/html5tx2013/embedded2.JPG"></p>

<p>Photo credit: Mitch Fincher: <a href="http://mitchfincher.blogspot.com/2013/02/pictures-from-html5tx-2013-in-austin-tx.html">mitchfincher.blogspot.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build a Milestone Calendar with IndexedDB and FullCalendar.js]]></title>
    <link href="http://jessecravens.com/blog/2013/01/17/build-a-milestone-calendar-with-indexeddb-and-fullcalendar-dot-js/"/>
    <updated>2013-01-17T08:47:00-06:00</updated>
    <id>http://jessecravens.com/blog/2013/01/17/build-a-milestone-calendar-with-indexeddb-and-fullcalendar-dot-js</id>
    <content type="html"><![CDATA[<h4>IndexedDB is a persistent object data store in the browser. Although it is not a full SQL implementation and it is more complex than the unstructured key–value pairs in localStorage, you can use it to define an API that provides the ability to read and write key–value objects as structured JavaScript objects, and an indexing system that facilitates filtering and lookup.</h4>

<p>For this hack we will use IndexedDB to store milestone objects for a calendar application. The UI will provide a simple means to create a new milestone and provide a title, start date, and end date. The calendar will then update to show the contents of the local data store. Figure 6-8 shows the result.</p>

<p>Figure 6-8. FullCalendar.js and IndexedDB</p>

<p><img class="figure" alt="Figure 6-8" src="http://jessecravens.com/images/chapter6-images/6-8.png"></p>

<p>We need to start by including the markup for the two pieces of the UI: the calendar and the form.
We’ll begin with the form. You may notice that the input fields for the dates include data-date-format attributes. We will use these later for the JavaScript date pickers.</p>

<p>{% codeblock milestone form %}
 <form></p>

<pre><code> &lt;fieldset&gt;

   &lt;div class="control-group"&gt;
     &lt;label class="control-label"&gt;Add a Milestone&lt;/label&gt;
     &lt;div class="controls"&gt;
       &lt;h2&gt;New Milestone&lt;/h2&gt;
       &lt;input type="text" name="title" value=""&gt;
       &lt;input type="text" class="span2" name="start"
         value="07/16/12" data-date-format="mm/dd/yy" id="dp1" &gt;
       &lt;input type="text" class="span2" name="end"
         value="07/17/12"  data-date-format="mm/dd/yy" id="dp2" &gt;
     &lt;/div&gt;
   &lt;/div&gt;

   &lt;div class="form-actions"&gt;
      &lt;button type="submit" class="btn btn-primary"&gt;Save&lt;/button&gt;
      &lt;button class="btn"&gt;Cancel&lt;/button&gt;
   &lt;/div&gt;

  &lt;/fieldset&gt;
</code></pre>

<p> </form>
{% endcodeblock %}</p>

<p>The calendar is provided by <a href="http://arshaw.com/fullcalendar/">FullCalendar.js</a>, a fantastic jQuery plug-in for generating robust calendars from event sources. The library will generate a calendar from a configuration object and a simple div.</p>

<p>{% codeblock simple div %}</p>

<div id='calendar'></div>


<p>{% endcodeblock %}</p>

<p>And we can’t forget to include a few dependencies:</p>

<p>{% codeblock CSS and JavaScript dependencies %}
<link href="../assets/css/datepicker.css" rel="stylesheet">
<link href="../assets/css/fullcalendar.css" rel="stylesheet"></p>

<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>


<script src="../assets/js/bootstrap-datepicker.js"></script>


<script src="../assets/js/fullcalendar.min.js"></script>


<p>{% endcodeblock %}</p>

<p>To improve the user experience, we will also include date pickers for choosing the dates within the form fields for start and end dates (see Figure 6-9).</p>

<p>Figure 6-9. Date pickers</p>

<p><img class="figure" alt="Figure 6-9" src="http://jessecravens.com/images/chapter6-images/6-9.png"></p>

<p>To instantiate the date pickers we will include the following toward the beginning of our script:</p>

<p>{% codeblock instantiate the date pickers %}
$(function(){</p>

<pre><code>$('#dp1').datepicker();
$('#dp2').datepicker();
</code></pre>

<p>  });
{% endcodeblock %}</p>

<h3>The Milestone IndexedDB</h3>

<p>Now we will set up a global namespace to hold our code, and set up a public milestones array (within the namespace) to hold our milestones temporarily while we pass them between our database and the FullCalendar API. This should make more sense as you continue to read. While we are at it we will need to normalize our indexedDB variable across all of the vendor-specific properties.</p>

<p>{% codeblock namespace and normalize %}
var html5hacks = {};</p>

<p>html5hacks.msArray = [];</p>

<p>var indexedDB = window.indexedDB || window.webkitIndexedDB ||</p>

<pre><code>            window.mozIndexedDB;
</code></pre>

<p>if ('webkitIndexedDB' in window) {
  window.IDBTransaction = window.webkitIDBTransaction;
  window.IDBKeyRange = window.webkitIDBKeyRange;
}
Now we can begin to set up our database:
html5hacks.indexedDB = {};
html5hacks.indexedDB.db = null;</p>

<p>function init() {
  html5hacks.indexedDB.open();
}</p>

<p>init();
{% endcodeblock %}</p>

<p>This will obviously fail for now, but as you can see the initialization begins by calling the open() method on an html5hacks.indexedDB. So let’s take a closer look at open():</p>

<p>{% codeblock open() %}
html5hacks.indexedDB.open = function() {</p>

<p>  var request = indexedDB.open("milestones");</p>

<p>  request.onsuccess = function(e) {</p>

<pre><code>var v = "1";
html5hacks.indexedDB.db = e.target.result;

var db = html5hacks.indexedDB.db;

if (v!= db.version) {
  var setVrequest = db.setVersion(v);
  setVrequest.onerror = html5hacks.indexedDB.onerror;

  setVrequest.onsuccess = function(e) {
    if(db.objectStoreNames.contains("milestone")) {
      db.deleteObjectStore("milestone");
    }

    var store = db.createObjectStore("milestone",
      {keyPath: "timeStamp"});

    html5hacks.indexedDB.init();
  };
}
else {
  html5hacks.indexedDB.init();
}
</code></pre>

<p>  };
  request.onerror = html5hacks.indexedDB.onerror;
}
{% endcodeblock %}</p>

<p>First, we need to open the database and pass a name. If the database successfully opens and a connection is made, the onsuccess() callback will be fired.</p>

<p>Within the onsuccess, we then check for a version and call setVersion() if one does not exist. Then we will call createObjectStore() and pass a unique timestamp within the keypath property.</p>

<p>Finally, we call init() to build the calendar and attach the events present in the database.</p>

<p>{% codeblock onsuccess() %}
html5hacks.indexedDB.init = function() {</p>

<p>  var db = html5hacks.indexedDB.db;
  var trans = db.transaction(["milestone"], IDBTransaction.READ_WRITE);
  var store = trans.objectStore("milestone");</p>

<p>  var keyRange = IDBKeyRange.lowerBound(0);
  var cursorRequest = store.openCursor(keyRange);</p>

<p>  cursorRequest.onsuccess = function(e) {</p>

<pre><code>var result = e.target.result;

if(!result == false){

    $('#calendar').fullCalendar({
      header: {
        left: 'prev,next today',
        center: 'title',
        right: 'month,agendaWeek,agendaDay'
      },
      weekmode: 'variable',
      height: 400,
      editable: true,
      events: html5hacks.msArray
    });

  return;

}else{

  console.log("result.value" , result.value);
  buildMilestoneArray(result.value);
  result.continue();
}
</code></pre>

<p>  };
  cursorRequest.onerror = html5hacks.indexedDB.onerror;
};</p>

<p>{% endcodeblock %}</p>

<p>At this point we are poised to retrieve all the data from the database and populate our calendar with milestones.
First, we declare the type of transaction to be a READ_WRITE, set a reference to the datastore, set a keyrange, and define a cursorRequest by calling openCursor and passing in the keyrange. By passing in a 0, we ensure that we retrieve all the values greater than zero. Since our key was a timestamp, this will ensure we retrieve all the records.</p>

<p>Once the onsuccess event is fired, we begin to iterate through the records and push the milestone objects to buildMilestoneArray:</p>

<p>{% codeblock buildMilestoneArray() %}
function buildMilestoneArray(ms) {
  html5hacks.msArray.push(ms);
}
When we reach the last record, we build the calendar by passing a configuration object to fullCalendar() and returning:</p>

<pre><code>    $('#calendar').fullCalendar({
      header: {
        left: 'prev,next today',
        center: 'title',
        right: 'month,agendaWeek,agendaDay'
      },
      weekmode: 'variable',
      height: 400,
      editable: true,
      events: html5hacks.msArray
    });

  return;
</code></pre>

<p>{% endcodeblock %}</p>

<h3>Adding Milestones</h3>

<p>Now that we are initializing and building our calendar, we need to begin adding milestones to the database via the form. First let’s use jQuery to set up our form to pass a serialized data object to addMilestone() on each submission:</p>

<p>{% codeblock form submit %}
  $('form').submit(function() {</p>

<pre><code>var data = $(this).serializeArray();

html5hacks.indexedDB.addMilestone(data);
return false;
</code></pre>

<p>  });
{% endcodeblock %}</p>

<p>Now let’s submit a few events and then view them in the Chrome Inspector to ensure they are there (see Figure 6-10).</p>

<p>Figure 6-10. Viewing milestone objects in the Chrome Inspector</p>

<p><img class="figure" alt="Figure 6-10" src="http://jessecravens.com/images/chapter6-images/6-10.png"></p>

<p>Let’s take a closer look at our addMilestone method:</p>

<p>{% codeblock addMilestone() %}
html5hacks.indexedDB.addMilestone = function(d) {
  var db = html5hacks.indexedDB.db;
  var trans = db.transaction(["milestone"], IDBTransaction.READ_WRITE);
  var store = trans.objectStore("milestone");</p>

<p>  var data = {</p>

<pre><code>"title": d[0].value,
"start": d[1].value,
"end": d[2].value,
"timeStamp": new Date().getTime()
</code></pre>

<p>  };</p>

<p>  var request = store.put(data);</p>

<p>  var dataArr = [data]
  request.onsuccess = function(e) {</p>

<pre><code>$('#calendar').fullCalendar('addEventSource', dataArr);
</code></pre>

<p>  };</p>

<p>  request.onerror = function(e) {</p>

<pre><code>console.log("Error Adding: ", e);
</code></pre>

<p>  };
};
{% endcodeblock %}</p>

<p>We established our read/write connection in much the same way as our html5hacks.indexedDB.init(), but now, instead of only reading data, we write a data object to the data store each time by calling store.put() and passing it data. On the onsuccess we then can call fullcalendar’s addEventSource() and pass it the data wrapped in an array object. Note that it is necessary to transform the data object into an array since that is what the FullCalendar API expects.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Client/Server 3.0: 6 Ways JavaScript is Revolutionizing the Client/Server Relationship]]></title>
    <link href="http://jessecravens.com/blog/2012/11/28/client-server-3-dot-0-6-ways-javascript-is-revolutionizing-the-client-server-relationship/"/>
    <updated>2012-11-28T10:02:00-06:00</updated>
    <id>http://jessecravens.com/blog/2012/11/28/client-server-3-dot-0-6-ways-javascript-is-revolutionizing-the-client-server-relationship</id>
    <content type="html"><![CDATA[<p>Im giving a talk at Devcon 5 - San Francisco this afternoon: Client/Server 3.0: 6 Ways JavaScript is Revolutionizing the Client/Server Relationship. Here is the other talks on the agenda: <a href="http://www.html5report.com/conference/california/agenda.aspx">Devcon 5 - San Francisco</a>.</p>

<p>Here is a brief summary:</p>

<h3>1 Device Access Within the Browser</h3>

<p>The client gets smarter.</p>

<p>JavaScript Device APIs continue to evolve, allowing more access to device hardware, services and applications such as the camera, microphone, system sensors, native address books, calendars and native messaging applications.
We will explore examples utilizing GeoLocation API, and Device Orientation.</p>

<h3>2 Client Side Processing w/ Background Threads</h3>

<p>The modern web browser's runtime is a single threaded, event loop. Asynchronous programming models, reactionary systems design actually benefit from this architecture. Maturing interpreters improve performance. Web Workers API enables background threads in the browser, making heavy computations realistic.</p>

<p>So, the client gets more powerful, and becomes an application development evnvironment.
We will explore Web Workers processing heavy computations without blocking the UI for further user interaction.</p>

<h3>3 Device Detection and Descriptors / Adaptive Frameworks</h3>

<p>Responsive Web Design is great, but it often isn't enough for larger applications, and applications that need to reach a highly fragmented device market. Adaptive frameworks use DDRs (Device Description Repositories)</p>

<p>We will explore a framework that mixes the best of Responsive with the best of Adaptive: <a href="https://github.com/jessecravens/responderjs">responderJS</a>.</p>

<h3>4 HTML5 Connectivity Revolution and HTTP 2.0</h3>

<p>Peter Lubbers coined the term, HTML5 Connectivity Revolution, to describe the next level, web network technologies such as: Web Sockets API, XHR2, Event Source and Server Sent Events, SPDY, CORS.</p>

<p>Engage in a demo of <a href="https://github.com/jessecravens/robodeck">robodeck</a>, a Web Socket driven Collaborative presenations framework.</p>

<h3>5 Single Runtime, Shared Syntax ... the right way</h3>

<p>Node.js has enabled the same language, single runtime. But, the paradigms are still quite different. Node streams, inspired by Linux pipes, make IO easy and intuitive. Explore pipe(), pump(), and events in Node streams.</p>

<p>Solutions like Browserify, help bring Node.js libraries and NPM dependency management to the browser. Next up, Domnode, wrapping common, client-side, I/O bound APIs (XHR, SSE, WebRTC, etc.) in Node streams syntax.</p>

<h3>6 Embedded JavaScript</h3>

<p>With Node.js, Angstrom Linux, and cloud document stores like MongoDB, the server is now embedded in the microcontroller client.</p>

<p>We will explore Arduino wrappers, and Node.js running on the Beaglebone from Texas Instruments.</p>

<p>The combination of Linux and JavaScript open worlds of opportunity.</p>

<p>Here is the node.js server used on the Beaglebone in the demo: <a href="https://github.com/jessecravens/beagleserver">beagleserver</a>.
The Johnny Five code is located here: <a href="https://github.com/nodejshacks/nodejshacks-embedded">node-embedded</a></p>

<script async class="speakerdeck-embed" data-slide="4" data-id="086813701bf601302fbe22000a1f8a4e" data-ratio="1.2994923857868" src="http://jessecravens.com//speakerdeck.com/assets/embed.js"></script>




<iframe width="560" height="315" src="http://www.youtube.com/embed/eahWOUYqr90" frameborder="0" allowfullscreen></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Modules]]></title>
    <link href="http://jessecravens.com/blog/2012/06/17/javascript-modules/"/>
    <updated>2012-06-17T16:23:21-05:00</updated>
    <id>http://jessecravens.com/blog/2012/06/17/javascript-modules</id>
    <content type="html"><![CDATA[<p>For a talk last March at USAA's internal Tech X conference, I put together a demo of JavaScript script loaders, module definitions, dependency management, and polyfill support: <a href="http://jessecravens.github.com/js-modules-demo">JavaScript Modules</a>.</p>


<p><a href="http://jessecravens.github.com/js-modules-demo/"><img class="imgL" width="500px" src="http://jessecravens.com/images/blogposts/js-modules.png"></a></p>

<p>This demonstrates the following Module Definitions:</p>




<ul>
<li>AMD</li>
<li>CommonJS</li>
<li>YUI3</li>
<li>JS Harmony</li>
</ul>




<p>And a few script loaders:</p>




<ul>
<li>RequireJS</li>
<li>yepnope</li>
<li>YUI3 - YUI Loader</li>
</ul>




<p>If you want to know more about the state of modules, dependency loading and management in the JavaScript world, there is always room for more contributors, just fork or clone the project ... and you will have a playground to begin playing with some of the most popular implementations.</p>


<p>To learn more, check it out here: <a href="http://jessecravens.github.com/js-modules-demo/">jessecravens.github.com/js-modules-demo</a></p>



]]></content>
  </entry>
  
</feed>
